<!DOCTYPE html>
<html>
  <title> Rubik'Statistics </title>
  <head>
    <link rel="stylesheet" href="../css/theme_mobile_dark.css">
  </head>

  <body>
    <h3> Rubik'Statistics </h3>

    <nav style="position:absolute;margin-top:-70px;">
      <div>
        <a href='page_dark.html'><button class="color_mode"> Dark </button></a>
        <a href='page_mobile_dark.html'><button class="color_mode"> Dark Mobile </button></a>
      </div>
      <div>
        <a href='page_light.html'><button class="color_mode"> Light </button></a>
        <a href='page_mobile_light.html'><button class="color_mode"> Light Mobile </button></a>
      </div>
    </nav>

    <table>
      <tr align="center">
        <td><input type="file" id="fileUpload" size="10"></td>
        <td> Filetype:
          <div>
            <input list="application" type="text" id="choice_application" size="9" value="Cube Timer"></input>
            <datalist id="application">
              <option value="Cube Timer">
            </datalist>
          </div>
        </td>
        <td colspan="2"> Exponential Regression </td>
      </tr>
      <tr>
        <td width="40%"><label for="choix_cubes">Indiquez le cube :</label></td>
        <td>
          <div>
            <input list="cubes" type="text" id="choix_cubes" size="5" value="7x7x7"></input>
            <datalist id="cubes">
              <option value="2x2x2">
              <option value="3x3x3">
              <option value="4x4x4">
              <option value="5x5x5">
              <option value="6x6x6">
              <option value="7x7x7">
              <option value="Megaminx">
            </datalist>
          </div>
        </td>
        <td> Avg </td>
        <td><input id="avg_reg_input" type="text" name="text_input" required minlength="1" size="1" value=50></input></td>
      </tr>
      <tr>
        <td><label> Nombre de cubes : </label></td>
        <td><input id="periode_input" type="text" name="text_input" required minlength="1" size="3" value=100>/<label id="nb_chronos"></label></input></td>
        <td> Estimation number cube required to sub <input id="sub_reg_input" type="text" name="text_input" required minlength="1" size="1" value=120>s</input></td>
        <td><label id="estimation_nb_cube_sub"></label></td>
      </tr>
      <tr>
        <td colspan="4"><button type="button" name="button" onclick="main_dark()" style="width:100%"> Display </button></td>
      </tr>
    </table>
    <br></br>

    <table>
      <tr>
        <td id="PB" width="32%">PB:</td>
        <td colspan=2 width="23%">Moyenne</td>
      	<td colspan=2 width="23%">Ecart-type</td>
      	<td colspan=2 width="23%">Coeff de corr&eacute;lation</td>
      </tr>
      <tr>
        <td>5 derniers</td>
        <td width="1%"><input type="checkbox" id="avg5_check" class="largerCheckbox" defaultChecked="True" checked="True" ></td>
        <td id="avg5"></td>
        <td width="1%"><input type="checkbox" id="ect5_check" class="largerCheckbox"></td>
        <td id="ect5"></td>
        <td width="1%"><input type="checkbox" id="std5_check" class="largerCheckbox" defaultChecked="True" checked="True"></td>
      	<td id="std5"></td>
      </tr>
      <tr>
        <td>12 derniers</td>
        <td><input type="checkbox" id="avg12_check" class="largerCheckbox" defaultChecked="True" checked="True">
        </td><td id="avg12"></td>
        <td><input type="checkbox" id="ect12_check" class="largerCheckbox"></td>
        <td id="ect12"></td>
        <td><input type="checkbox" id="std12_check" class="largerCheckbox" defaultChecked="True" checked="True"></td>
      	<td id="std12"></td>
      </tr>
      <tr>
        <td>50 derniers</td>
        <td><input type="checkbox" id="avg50_check" class="largerCheckbox" defaultChecked="True" checked="True"></td>
        <td id="avg50"></td>
        <td><input type="checkbox" id="ect50_check" class="largerCheckbox"></td>
        <td id="ect50"></td>
        <td><input type="checkbox" id="std50_check" class="largerCheckbox" defaultChecked="True" checked="True"></td>
      	<td id="std50"></td>
      </tr>
      <tr>
        <td>100 derniers</td>
        <td><input type="checkbox" id="avg100_check" class="largerCheckbox" defaultChecked="True" checked="True"></td>
        <td id="avg100"></td>
        <td><input type="checkbox" id="ect100_check" class="largerCheckbox"></td>
        <td id="ect100"></td>
        <td><input type="checkbox" id="std100_check" class="largerCheckbox" defaultChecked="True" checked="True"></td>
      	<td id="std100"></td>
      </tr>
      <tr>
        <td>1000 derniers</td>
        <td><input type="checkbox" id="avg1000_check" class="largerCheckbox" defaultChecked="True" checked="True"></td>
        <td id="avg1000"></td>
        <td><input type="checkbox" id="ect1000_check" class="largerCheckbox"></td>
      	<td id="ect1000"></td>
        <td><input type="checkbox" id="std1000_check" class="largerCheckbox" defaultChecked="True" checked="True"></td>
      	<td id="std1000"></td>
      </tr>
    </table>

    <div>
      <canvas id="canvas" height=1500 width=1500></canvas>
    </div>

    <div>
      <p>
        Le Graphique du Coefficient de Corr&eacute;lation indique la ma&icirc;trise ou non de votre m&eacute;thode de r&eacute;solution actuelle.
        Si votre CC est en dessous de 8.0, vous ma&icirc;trisez votre m&eacute;thode et il serait avantageux d'apprendre de nouvelles formules ou techniques.
        Si votre CC est entre 8.0 et 12.0, vous &ecirc;tes dans une progression constante.
        Si votre CC est au dessus de 12.0, il faut vous entra&icirc;ner d'avantage pour vous am&eacute;liorer.
        Il est conseill&eacute; d'utiliser le CC avec la plus grande moyenne (std100 ou std1000).
      </p>
      <p>Le coefficient de &eacute;cart-type est de 1.96 soit 95% des chronos sont compris dans l'intervalle de confiance.</p>
    </div>

    <script>
      function mobile_average(liste, n) { // moyenne mobile de période n
        var mobile_average_liste = [] ;
        for (var i=0; i<liste.length-n+1; i++) {
          var somme = 0 ;
          for (var j=0; j<n; j++) {
            somme+=liste[i+j] ;
          }
          mobile_average_liste.push(somme/n) ;
        }
        return (mobile_average_liste) ;
      }

      function ecart_type(liste, n) { // écart-type de période n
        var ecart_type_liste = mobile_average(liste, n) ;
        for (var i=0; i<ecart_type_liste.length; i++) {
          ecart_type_liste[i] = Math.pow(ecart_type_liste[i],2) ;
        }
        for (var i=0; i<liste.length-n+1; i++) {
          var temp = 0 ;
          for (var j=0; j<n; j++) {
            temp+=Math.pow(liste[i+j],2) ;
          }
          ecart_type_liste[i] = Math.abs(ecart_type_liste[i]-temp/n) ;
        }
        for (var i=0; i<ecart_type_liste.length; i++) {
          ecart_type_liste[i] = Math.sqrt(ecart_type_liste[i]) ;
        }
        return (ecart_type_liste) ;
      }

      function standard_deviation(liste, n) { // coefficient de corrélation de période n
        var coef_liste = [] ;
        const ect = ecart_type(liste, n) ;
        const mav = mobile_average(liste, n) ;
        for (var i=0; i<liste.length-n+1; i++) {
          coef_liste.push(100*ect[i]/mav[i]) ;
        }
        return (coef_liste) ;
      }


      function time_to_compte(liste) {
        return(liste[0]*60+liste[1]) ;
      }

      function compte_to_time(n) {
        const min = parseInt(n/60)
        return(String(min)+":"+String(Math.round((n-min*60)*1000)/1000)) ;
      }

      function valeurs_tableau(liste, val) {
        document.getElementById("nb_chronos").innerHTML = " "+String(liste.length) ;
        for (var i=1; i<val.length; i++) {
          const n = val[i] ;
          if (liste.length>=n) {
            affichage("avg"+String(n),"ect"+String(n),"std"+String(n), liste, n) ;
          }
          else {
            vide("avg"+String(n),"ect"+String(n),"std"+String(n)) ;
          }
        }
      }

      function affichage(avg,ect,std, liste, n) {
        document.getElementById(avg).innerHTML = compte_to_time(mobile_average(liste, n)[0]) ;
        document.getElementById(ect).innerHTML = Math.round(ecart_type(liste, n)[0]*1000)/1000 ;
        document.getElementById(std).innerHTML = Math.round(standard_deviation(liste, n)[0]*1000)/1000 ;
      }

      function vide(avg,ect,std) {
        document.getElementById(avg).innerHTML = "" ;
        document.getElementById(ect).innerHTML = "" ;
        document.getElementById(std).innerHTML = "" ;
      }

      function maxi_liste(liste) {
        var maxi = liste[0] ;
        for (var i=1; i<liste.length; i++) {
          if (liste[i]>maxi) {
            maxi = liste[i] ;
          }
        }
        return(maxi) ;
      }

      function mini_liste(liste) {
        var mini = liste[0] ;
        for (var i=1; i<liste.length; i++) {
          if (liste[i]<mini) {
            mini = liste[i] ;
          }
        }
        return(mini) ;
      }


      function draw_single_line(context,x1,y1,x2,y2,color) {
        context.fillStyle = color ;
        context.strokeStyle = color ;
        context.beginPath();
        context.moveTo(x1, y1);
        context.lineTo(x2, y2);
        context.stroke();
      }

      function draw_arc(context, x, y, r_courbure) {
        context.beginPath();
        context.arc(x, y, r_courbure, 0, 2*Math.PI);
        context.stroke();
      }

      function draw_text(context, text,x,y,color,size) {
        context.fillStyle = color ;
        context.strokeStyle = color ;
        context.font = String(size)+'px helvetica' ;
        context.fillText(text, x,y) ;
      }


      function graphique(canvas,context,liste, val,color,style,scale, d,l) { // val=valeurs des moyennes; d=distance par rapport au bord haut du canvas; l=largeur du graphique
        const height = canvas.height, width = canvas.width ;
        const x_max = maxi_liste(liste), x_min = mini_liste(liste) ;
        const x_m = (x_max+x_min)/2 ;
        const dist = d-x_m, c = l/(x_max-x_min) ;
        var i = 0 ;

        // plot grid
        grid_plot(canvas,context,scale,x_min,x_max,c,d,x_m,"gray") ;

        // plot chrono & meilleurs chrono
        if (val[i]===1) {
          var liste_temp = [] ;
          for (var j=0; j<=liste.length-val[i]; j++) {
            liste_temp.push(height-((liste[j]-x_m)*c+d)) ;
          }
          plot(context, liste_temp, width,val[i],color[i],style[i],"") ;
          // plot meilleur chrono
          plot_pb(canvas,context,liste_temp, "pink",val[i] , x_m,c,d) ;
        }

        // plot moyenne & écart-type
        for (i=1; i<val.length; i++) {
          const text = "avg"+String(val[i]) ;
          if (document.getElementById(text+"_check").checked===true && liste.length>=val[i]) {
            const offset = val[i] ;
            var avg_liste = mobile_average(liste,offset) ;
            var ect_liste = ecart_type(liste,offset) ;
            for (var j=0; j<=liste.length-val[i]; j++) {
              avg_liste[j] = height-((avg_liste[j]-x_m)*c+d) ;
              ect_liste[j] = (ect_liste[j])*c ;
            }
            plot(context, avg_liste, width,offset,color[i],style[i],text) ;
            if (document.getElementById("ect"+String(val[i])+"_check").checked===true) {
              const n = 1.96 // intervalle de confiance
              plot_ecart_type_I(canvas,context, avg_liste,ect_liste, color[i],offset, n) ;
              plot_ecart_type_II(canvas,context, avg_liste,ect_liste, color[i],offset, n) ;
            }
          }
        }
      }

      function plot(context, y, width,offset, color,style,text) {
        const margin = 100 ; // marge par rapport au bord droit
        const len = y.length
        context.fillStyle = color ;
        context.strokeStyle = color ;
        context.beginPath() ;
        context.moveTo(offset*(width-margin)/(len+offset), y[len-1]) ;
        for (var i=1; i<len; i++) {
          context.lineTo((i+offset)*(width-margin)/(len+offset), y[len-i-1]) ;
        }
        context.stroke() ;
        if (style===".-") {
          for (var i=0; i<len; i++) {
            draw_arc(context, (i+offset)*(width-margin)/(len+offset), y[len-i-1],2) ;
          }
        }
        draw_text(context, text, (width-margin), y[0],color,17) ;
      }

      function plot_pb(canvas,context,liste, color,offset, x_m,c,d) {
        const height = canvas.height, width = canvas.width ;
        const margin = 100 ; // marge par rapport au bord droit
        liste.reverse() ;
        var pbliste = [0,liste[0]] ;
        for (var i=1; i<liste.length; i++) {
          if (liste[i]>pbliste[1]) {
            draw_single_line(context, (pbliste[0]+offset)*(width-margin)/(liste.length+offset),
                                      pbliste[1],
                                      (i+offset)*(width-margin)/(liste.length+offset),
                                      liste[i],color) ;
            pbliste = [i,liste[i]] ;
          }
        }
        document.getElementById("PB").innerHTML = "PB: "+compte_to_time((height-pbliste[1]-d)/c+x_m) ;
        liste.reverse() ;
      }

      function grid_plot(canvas,context,scale,mini,maxi,c,d,x_m,color) {
        for (var i=parseInt(mini); i<=parseInt(maxi); i+=scale) {
          const y = canvas.height-((i-x_m)*c+d) ;
          draw_single_line(context, 0,y, canvas.width,y, color) ;
          draw_text(context, String(compte_to_time(i)),canvas.width-40,y,color,17) ;
        }
      }

      function grid_std(canvas,context,scale,mini,maxi,c,d,x_m,color) {
        for (var i=parseInt(mini); i<=parseInt(maxi); i+=scale) {
          const y = canvas.height-((i-x_m)*c+d) ;
          if (i==8 || i==12) {
            draw_single_line(context, 0,y, canvas.width,y, "red") ;
            draw_text(context, String(i),canvas.width-40,y,"red",17) ;
          }
          else {
            draw_single_line(context, 0,y, canvas.width,y, color) ;
            draw_text(context, String(i),canvas.width-40,y,color,17) ;
          }
        }
      }

      function plot_ecart_type_I(canvas,context, avg_liste,ect_liste, color,offset,n) { // n=pour intervalle de confiance n=1.95 -> 95%
        const len = avg_liste.length ;
        const margin = 100, height = canvas.height, width = canvas.width ;
        for (var i=0; i<len; i++) {
          if ((len-i-1)%10===0) {
            draw_single_line(context,(i+offset)*(width-margin)/(len+offset),
                                     avg_liste[len-i-1]+n*ect_liste[len-i-1],
                                     (i+offset)*(width-margin)/(len+offset),
                                     avg_liste[len-i-1]-n*ect_liste[len-i-1],
                                     color) ;
          }
        }
      }

      function plot_ecart_type_II(canvas,context, avg_liste,ect_liste, color,offset,n) {
        var ect_up = [], ect_down = [] ;
        for (var i=0; i<avg_liste.length; i++) {
          ect_up.push(avg_liste[i]+n*ect_liste[i]) ;
          ect_down.push(avg_liste[i]-n*ect_liste[i]) ;
        }
        plot(context, ect_up,canvas.width,offset, color,"-","") ;
        plot(context, ect_down,canvas.width,offset, color,"-","") ;
      }

      function graph_coeff_corr(canvas,context,liste,val,color,style,d,l) {
        // recherche du min et du max de coefficient de correlation
        var x_max = maxi_liste(standard_deviation(liste,val[1])), x_min = mini_liste(standard_deviation(liste,val[1])) ;
        for (var i=2; i<val.length; i++) {
          if (liste.length>val[i]) {
            var max_temp = maxi_liste(standard_deviation(liste,val[i])) ;
            var min_temp = mini_liste(standard_deviation(liste,val[i])) ;
            if (max_temp+1>x_max) {
              x_max = max_temp+1 ;
            }
            if (min_temp-1<x_min) {
              x_min = min_temp-1 ;
            }
          }
        }

        const x_m = (x_max+x_min)/2 ;
        const dist = d-x_m, c = l/(x_max-x_min) ;

        grid_std(canvas,context,1,x_min,x_max,c,d,x_m,"gray") ;

        for (var i=1; i<val.length; i++) {
          if (document.getElementById("std"+String(val[i])+"_check").checked===true) {
            const text = "std"+String(val[i]) ;
            if (liste.length>=val[i]) { // && document.getElementById(text+"_check").checked===true) {
              const offset = val[i] ;
              var std_liste = standard_deviation(liste,offset) ;
              for (var j=0; j<=liste.length-val[i]; j++) {
                std_liste[j] = canvas.height-((std_liste[j]-x_m)*c+d) ;
              }
              plot(context, std_liste, canvas.width,offset,color[i],style[i],text) ;
              // ajouter un écart-type ?
            }
          }
        }
      }


      function main() {
        Upload("normal") ;
      }

      function main_dark() {
        Upload("dark") ;
      }

      function Upload(theme) {
        const categorie = String(document.getElementById("choix_cubes").value) ;
        var fileUpload = document.getElementById("fileUpload") ;
        var regex = /^([a-zA-Z0-9\s_\\.\-:])+(.csv|.txt)$/;

        if (regex.test(fileUpload.value.toLowerCase())) {
          if (typeof (FileReader) != "undefined") {
            var reader = new FileReader() ;
            reader.onload = function (e) {
              var liste = [] ;
              var table = document.createElement("table") ;
              var rows = e.target.result.split("\n") ;
              const periode = parseInt(document.getElementById("periode_input").value) ;

              // cherche les données dans le fichier .csv
              for (var i = 0; i < rows.length; i++) {
                var row = table.insertRow(-1);
                var cells = rows[i].split(","); // isole les lignes
                /*for (var j = 0; j < cells.length; j++) {
                  var cell = row.insertCell(-1);
                  cell.innerHTML = cells[j];
                }
                */
                var subcells = cells[0].split(";") ; // isole les composantes des lignes
                if (subcells[0]===categorie) { // sélection de la catégorie
                  const sub1 = subcells[1].split(":") ;
                  var min = parseFloat(sub1[0]) ; // minutes
                  var sec = parseFloat(sub1[1]) ; // secondes avec millisecondes
                  var compt = time_to_compte([min,sec]) ;
                  liste.push(compt) ;
                }
              }


              var canvas = document.getElementById("canvas") ;
              var context = canvas.getContext("2d") ;
              const len_l = liste.length ;

              const val   = [ 1,      5,    12,      50,     100,   1000] ;
              var color ;
              if (theme==="dark") {
                color = ["white",'#F30','#FD0','#6C0','#09F',"purple"] ;
              }
              else {
                color = ["black","red","orange","green","blue","purple"] ;
              }
              const style = [".-",   "-",  "-",     "-",    "-",   "-"] ;

              const type_cube = ["2x2x2","3x3x3","4x4x4","5x5x5","6x6x6","7x7x7","Megaminx"] ;
              var scale_table = [ 1,      1,      10,     15,     15,     15,     10] ;
              var scale = 1 ;

              context.clearRect(0,0, canvas.width, canvas.height) ;

              valeurs_tableau(liste, val) ;

              // restriction du nombre de données
              if (len_l>periode) {
                for (var i=0; i<len_l-periode; i++) {
                  liste.pop(0) ;
                }
              }

              // choix de l'échelle de la grille
              for (var i=0; i<type_cube.length; i++) {
                if (categorie===type_cube[i]) {
                  scale = scale_table[i] ;
                  break ;
                }
              }

              // graphique chrono & moyenne & écart-type
              draw_text(context, "Graphique des Chronos",10,30,color[0],26) ;
              graphique(canvas,context,liste,val,color,style,scale, 1000,940) ; // d = distance par rapport au bord haut du canvas; l = largeur du graphique

              // graphique coefficient de corrélation
              draw_text(context, "Graphique du Coefficient de Corr\u00e9lation",10,1040,color[0],26) ;
              graph_coeff_corr(canvas,context,liste,val,color,style,250,440) ;
            }
            reader.readAsText(fileUpload.files[0]);
          }
          else {
            alert("This browser does not support HTML5.");
          }
        }
      }

    </script>
  </body>
</html>
